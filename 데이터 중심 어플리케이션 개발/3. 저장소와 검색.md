
## 저장소와 검색


가장 기본적 수준에서 데이터베이스는 두 가지 작업을 수행한다. 어떤 데이터를 받으면 데이터를 저장하고, 나중에 그 데이터를 요청하면 다시 데이터를 제공한다.

이 장에서는 데이터베이스가 데이터를 저장하는 방법과 데이터를 요청했을때 다시 찾을 수 있는 방법을 설명한다.

데이터 베이스가 저장과 검색을 내부적으로 처리하는 방법을 애플리케이션 개발자가 주의해야 하는 이유는 무엇일까?

주로 애플리케이션 개발자가 처음부터 자신의 저장소 엔진을 구현하는 경우는 거의 없으며 사용 가능한 여러 저장소 엔진 중에 애플리케이션에 적합한 엔진을 선택하는 작업이 필요하다.

특정 작업부하(워크로드) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있다.

특히 트랜젝션 작업부하에 맞춰 최적화된 저장소 엔진과 분석을 위해 최적화된 엔진 간에는 큰 차이가 있다.

우선 이번 장에서는 익숙한 데이터베이스 종류인 관계형 데이터베이스와 소위 NoSQL라 불리는 데이터베이스에 사용되는 저장소 엔진에 대해 설명한다.

그리고 로그 구조 계열 (log-structured) 저장소 엔진과 B-tree 같은 페이지 지향 계열 저장소 엔진을 검토한다.

### 데이터 베이스를 강력하게 만드는 데이터 구조

세상에서 가장 간단한 데이터베이스를 구상해보자.

두개의 배시 함수로 db_set()과 db_get()을 가진다.

키- 값 저장소를 함수 두개로 구현했으며 db_set key value를 호출하면 데이터베이스에 key와 value를 저장할 수 있다.
키와 값은 어떤 것이든 대부분 가능하다. 예를 들어 값이 json 문서가 될 수 도 있다. db_get key를 호출하면 해당 키와 연관된 가장 최근 값을 찾아 반환할 수 있다.

db_set과 마찬가지로 많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그를 사용한다.

실제 데이터베이스는 다뤄야할 더 많은 문제 (동시성 제어, 로그가 영원히 커지지 않게끔 디스크 공간을 회수, 오류 처리, 부분적으로 기록된 레코드 처리)가 있지만 기본 원리는 같다.
로그는 믿기지 않을 정도로 유용하다. 이 사실은 책 나머지 부분에서 여러 번 확인할 수 있다.

반면 db_get 함수는 데이터베이스에 많은 레코드가 있으면 성능이 매우 좋지 않다.
매번 키를 찾을 때마다 db_get은 키가 있는지 찾기 위해 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야 한다.
알고리즘 용어로 검색 비용이 O(n)이다. 데이터베이스의 레코드 수가 두배로 늘면 검색도 두배 오래 걸린다. 바람직하지 않다.

데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요하다.
바로 색인이다.
이번 장에서는 다양한 색인 구조를 살펴보고 여러 색인 구조를 비교하는 방법을 알아본다.

색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것이다.
이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움을 준다. 동일한 데이터를 여러가지 다양한 방법으로 검색하고자 한다면 데이터 각 부분에 여러가지 다양한 색인이 필요하다.

색인은 기본 데이터에서 파생된(primary data) 추가적인 구조다.
많은 데이터베이스는 색인의 추가와 삭제를 허용한다.
이 작업은 데이터베이스의 내용에는 영향을 미치지 않는다.
단지 질의 성능에만 영향을 준다.
추가적인 구조의 유지보수는 특히 쓰기 과정에서 오버헤드가 발생한다. 쓰기의 경우 단순히 파일에 추가할 때의 성능을 앞서기 어렵다. 왜냐하면 단순히 파일에 추가하는 작업이 제일 간단한 쓰기 작업이기 때문이다.
어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만든다.
이는 데이터를 쓸때 마다 매번 색인도 갱신해야 하기 때문이다.

이것은 저장소 시스템에서 중요한 트레이드 오프이다.
색인을 잘 선택했다면 읽기 질의 속도가 향상된다.
하지만 모든 색인은 쓰기 속도를 떨어뜨린다. 이런 이유로 데이터베이스는 보통 자동으로 모든 것을 색인하지 않는다.
애플리케이션 개발자나 데이터베이스 관리자가 애플리케이션의 전형적인 질의 패턴에 대한 지식을 활용해 수동으로 색인을 선택해야 한다. 그래야 필요 이상으로 오버헤드를 발생시키지 않으면서 애플리케이션에 가장 큰 이익을 안겨주는 색인을
선택할 수 있다.


### 해시 색인
