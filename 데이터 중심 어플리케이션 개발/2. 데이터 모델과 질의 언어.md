## 2. 데이터모델과 질의 언어


데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 지대한 영향을 미치기 때문에 중요하다.

애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.

이번 장에서는 데이터 저장과 질의를 위한 다양한 범용 데이터 모델을 살펴본다.


### 관계형 모델과 문서 모델

오늘 날 가장 잘 알려진 데이터 모델은 SQL이다.
데치터는 관계로 구성되고 각 관계는 순서없는 튜플에서 로우 모음이다.

근원은 비즈니스 데이터 처리에 있으며 보통 트랜젝션 처리와 일괄 처리로 오늘날 관점에서는 일상적으로 수행되는 일이다.


#### NoSQL의 탄생

Not Only SQL
채택 이유에는 다음과 같은 다양한 원동력이 있다.
- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
- 상용 데이터 베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
- 관계형 모델에서 지원하지 않는 특수 질의 동작
- 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

### 객체 관계형 불일치
오늘날 대부분 애플리케이션은 객체 지향 프로그래밍 언어로 개발한다.
이를 데이터 모델에 저장하려면 거추장스러운 전환 계층이 필요하다.
이런 모델 사이의 분리를 종종 `임피던스 불일치` 라고 부른다.


### 다대일과 다대다 관계

앞 절의 예제 2-1에서 region_id와 industry_id는 그레이터 시애틀 구역과, 자선활동이 아닌 ID로 주어졌다.
왜일까?

사용자 인터페이스에 지역과 업계를 입력할 수 있는 자유 텍스트 필드가 있다면

평문으로 저장하는 편이 합리적이지만 지리적 지역과 업계의 표준 목록으로 드롭다운 리스트나 자동완성 기능을 만들어 사용자가 선택하게 하는데는 다음과 같은 장점이 있다.

- 프로필 간 일관된 스타일과 철자
- 모호함 회피(예를 들어 이름이 같은 여러 도시가 있는 경우)
- 갱신의 편의성, 이름이 한 곳에만 저장되므로 이름을 변경해야 하는 경우 전반적으로 갱신하기 쉽다. (예를 들어 정치적 사건으로 도시 이름이 변경되는 경우)
- 현지화 지원. 사이트를 다른 언어로 번역할 때 표준 목록을 현지화해 지역과 업계를 사이트를 보는 사람의 언어로 표시할 수 있다.
- 더 나은 검색, 예를 들어 워싱턴 주에 있는 자선가를 검색하려 할 때 지역 목록에 시애틀이 워싱턴에 있다는 사실을 부호화
  - (그레이터 시애틀 구역 문자열로는 워싱턴을 식별하지 못함) 할 수 있기 때문에 원하는 프로필을 찾을 수 있다.

ID나 텍스트 문자열의 저장 여부는 중복의 문제다.
ID를 사용하는 경우 (자선활동이라는 단어처럼) 사람에게 의미 있는 정보는 한 곳에만 저장하고
그것을 참조하는 모든 것은 ID를 사용한다.
텍스트를 직접 저장한다면 그것을 사용하는 모든 레코드에서 사람을 의미하는 정보를 중복해서 저장하게 된다.

ID를 사용하는 장점으로 ID자체는 아무런 의미가 없기 때문에 변경할 필요가 없다.
즉 식별 정보를 변경해도 ID는 동일하게 유지할 수 있다.
하지만 의미를 가지는 경우라면 미래에 언젠가는 ID를 변경해야 할 수도 있다.
만약 정보가 중복돼 있으면 모든 중복 항목을 변경해야 한다.
이것은 쓰기 오버헤드와 불일치(정보의 일부 중복은 갱신됐지만 다른 중복 항목이 갱신되지 않음)
위험이 있다.

이런 중복을 제거하는 일이 데이터베이스의 정규화 이면에 놓인 핵심 개념이다.

중복된 데이터를 정규화하려면 다대일 관계
(많은 사람들은 한 특정 지역에 살고 많은 사람들은 한 특정 업계에서 일한다)가 필요한데 
안타깝게도 다대일 관계는 문서 모델에 적합하지 ㅇ낳다.

관계형 데이터베이스에서는 조인이 쉽기 떄문에 ID로 다른 테이블의 로우를 참조하는 방식은 일반적이다.
문서 데이터베이스에서는 일대다 트리 구조를 위해 조인이 필요하지 않지만 조인에 대한 지원이 보통 약하다.

데이터 베이스 자체가 조인을 지원하지 않으면 데이터베이스에 대한 다중 질의를 만들어서 애플리케이션 코드에서 조인을 흉내내야 한다.



### 문서형 데이터베이스는 역사를 반복하고 있나?
관계형 데이터베이스는 일상적으로 다대다 관계와 조인을 사용하지만 문서 데이터베이스와 NoSQL은 데이터베이스에서 다대다 관계를 표현하는 
제일 좋은 방법에 대한 논쟁을 다시 열었다.

계층 모델 부터 시작해 관계형 모델, 네트워크 모델을 통한 해결책이 제시되었다.


### 네트워크 모델
네트워크 모델은 코다실 모델이라고도 부리며 계층 모델을 일반화한다.
계층 모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있다.
네트워크 모델에서 레코드는 다중 부모가 있을 수 있다.
예를 들어 '그레이터 시애틀 구역'을 위한 하나의 레코드는 이 지역에 사는 모든 사용자에 연결될 수 있다.
코다실 모델은 다대일 과 다대다 관계를 모델링 할 수 있다.

레코드 간 연결은 외래 키보다는 프로그래밍 언어의 포인터와 더 비슷하다.
(여전히 디스크에 저장되긴 한다.)
레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법이다.
이를 접근 경로라 한다.

네트워크 모델에는 다양한 접근 경로를 추적해야 하거나 데이터 모델을 바꾸는 작업이 어렵다는 문제가 있었다.

### 관계형 모델

대조적으로 관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것이다.
관계는 단순히 튜플(로우)의 컬렉션이 전부이다.
질의 최적화기가 자동으로 만들어 접근 경로를 따로 생각할 필요가 없다.


### 문서 데이터베이스와의 비교
문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다.
(positions, education, contact_info 같은 일대다 관계)

그러나 다대일과 다대다 관계를 표현시 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다.
외래키나 문서 참조를 통해 조인이나 후속 질의를 사용해 읽기 시점에 확인하여 다대일과 다대다 관계를 확인한다.


## 관계형 데이터베이스와 오늘날 문서 데이터베이스

둘을 비교하는 경우 내결함성과 동시성 처리를 포함해 고려해야 할 차이점이 많이 있다.

문서 데이터 모델을 선호하는 주요 이유는 스키마 유연성, 지역성에 기인한 더 나은 성능이다.
일부 애플리케이션은 사용하는 데이터 구조와 더 가깝다.

관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.


## 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?
애플리케이션에서 데이터가 문서와 비슷한 구조(일대다 관계 트리로 한번에 전체 트리를 적재)
라면 문서 모델을 사용하는 것이 좋다.

문서와 비슷한 구조를 여러 테이블로 나누어 찢는(shredding) 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킨다.


문서 모델에는 제한이 있는데 예를 들어 문서 내 중첩 항목을 바로 참조할 수는 없어서 사용자 251의 직위 목록의 두번째 항목과 같이 표현해야 한다.
하지만 문서가 너무 깊게 중첩되지 않으면 일반적으로 문제가 되지 않는다.

문서 데이터베이스의 미흡한 조인 지원은 애플리케이션에 따라 문제 일 수도 있고 아닐 수도 있다.
어떤 시점에 발생한 이벤트를 기록하는 문서 데이터베이스를 사용하는 분석 애플리케이션에서는 다대다 관계가 결코 필요하지 않다.

하지만 애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다.

비정규화로 조인의 필요성 줄이기가 가능하지만 애플리케이션 코드는 비정규화된 데이터의 일관성을 유지하기 위해 추가 작업을 해야한다.
조인은 애플리케이션 코드에서 데이터베이스에 다중 요청을 만들어 흉내낼수 있지만 복잡도가 애플리케이션으로 이동할 뿐만 아니라 보통 데이터베이스 내 특화된
코드로 수행되는 조인보다 더 느리다.
이런 경우에 문서 모델을 사용하는 것은 훨씬 더 복잡한 애플리케이션 코드와 나쁜 성능으로 이어질 수 있다.

일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지 말할 수 없다.
데이터 항목간에 존재하는 관계 유형에 따라 다르다.
상호 연결이 많은 데이터의 경우 문서 모델은 곤란하지만 관계형 모델은 무난하며 그래프 모델은 매우 자연스럽다.

## 문서 모델에서의 스키마 유연성
스키마가 없다는 뜻은 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는 다는 의미다.

접근 방식간 차이는 애플리케이션이 데이터 타입을 변경하고자 할 때 특히 뚜렷히 나타나낟.
예를 들어 하나의 필드에 사용자의 전체 이름을 저장하고 있지만 성과 이름을 분리해서 저장하고 싶다고 가정해보자.
문서 데이터베이스에서는 새로운 필드를 가진 새로운 문서를 작성하기 시작하고 애플리케이션에서는 예전 문서를 읽은 경우를 처리하는 코드만 있으면 된다.

`if (user && user.name && !user.first_name) {
  user.first_name = user.name.split(' ')[0];
}`

반면 `정적타입`의 데이터베이스 스키마에서는 보통 다음 행과 같이 마이그레이션을 수행한다.

`ALTER TABLE users ADD COLUMN first_name text;`

`UPDATE users SET first_name = split_part(name, ' ', 1);`

`UPDATE users SET first_name = substring_index(name, ' ', 1);`


스키마 변경은 느리고 중단 시간을 요구하기 때문에 평판이 나쁘다.
대부분 관계형 데이터베이스 시스템은 ALTER TABLE 문을 수밀리초 안에 수행한다.
MySQL은 상당히 예외적이다.
MySQL은 ALTER TABLE 시에 전체 테이블을 복사한다.
이는 큰 테이블을 변경할 대 수분에서 수 시간까지 중단시간이 발생한다는 의미다.
이런 제약을 회피할 수 있는 다양한 도구가 있음에도 말이다.



### 명령형 선언형 맵리듀스 질의

맵 리듀스는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델로, 구글에 의해 널리 알려졌다.
몽고DB, couchDB를 포함한 일부 NoSQL 데이터 저장소는 제한 된 형태의 맵리듀스를 지원한다.
이 매커니즘은 많은 문서를 대상으로 읽기 전용 질의를 수행할 때 사용한다.

맵리듀스는 선언형 질의 언어도 완전한 명령형 질의 API도 아닌 그 중간 정도에 있다.
질의 로직은 처리 프레임워크가 반복적으로 호출하는 조각 코드로 표현한다.

맵 리듀스는 여러 함수형 프로그래밍 언어에 있는 map(collect 라고도 함)과 reduce(fold나 inject라고도 함) 함수를 기반으로 한다.

예를 들어 해양 생물학자가 바다에서 동물을 볼 때마다 데이터베이스에 관찰 기록을 추가한다고 해보자.
지금부터 한달에 얼마나 자주 상어를 발견하는지 보고서를 작성하려고 한다.

포스트그레스큐엘에서는 다음과 같이 질의를 표현할 수 있다.

```sql
SELECT data_trun ('month' , observation_timestamp) AS observation_month, sum(num_animals) as total_animals

FROM observations

WHERE family = "Sharks"

GROUP BY observation_month;
```

이 질의는 먼저 상어과에 속하는 종만 보이도록 관측치를 필터링 한 후
관측치가 발생한 달력의 월로 그룹화하고 마지막으로 해당 달의 모든 관측치에 보여진 동물 수를 합친다.

같은 내용을 몽고DB의 맵리듀스 기능을 이용해 다음과 같이 표현할 수 있다.
```javascript
db.observations.mapReduce(
  function map(){
    var year = this.observation_timestamp.getFullYear();
    var month = this.observation_timestamp.getMonth() + 1;
    emit(month, this.num_animals);
  },
  function reduce(key, values) {
    return Array.sum(values);
  },
  {
    query: {family: "Sharks"},
    out: "monthlySharkReport"
  }
)
```

몽고 DB의 맵과 리듀스 함수는 수행할 때 약간 제약사항이 있다.
두 함수는 순수 함수여야 한다.
즉 입력으로 전달된 데이터만 사용하고 추가적인 데이터베이스 질의를 수행할 수 없어야 하며
부수효과가 없어야 한다.

이런 제약 사항 때문에 데이터베이스가 임의 순서로 어디서나 이 함수를 실행할 수 있고 장애가 발생해도 함수를 재실행할 수 있다.
이런 제약 사항이 있어도 map과 reduce함수는 여전히 강력하다.
문자열을 파싱하고 라이브러리 함수를 호출하고 계산을 실행하는 등의 작업을 map과 reduce 함수에서 할 수 있다.

클러스터 환경에서 분산 실행을 위한 프로그래밍 모델인 맵 리듀스는 상당히 저수준 프로그래밍 모델이다.
SQL 같은 고수준 질의 언어도 맵리듀스 연산의 파이프라인으로 구현할 수 있지만 맵 리듀스를 사용하지 않은 분산 SQL 구현도 많다.
SQL 에 단일 장비에서 수행되도록 제한하는 것은 없으며 맵리듀스가 분산질의 실행에 대한 독점권을 가진 것도 아니다.

질의 중간에 자바스크립트 코드를 사용할 수 있다는 점은 고급 질의가 가능한 훌륭한 기능이지만 맵리듀스에서만 해당하는 것은 아니다.

맵 리듀스의 사용성 문제는 연계된 자바스크립트 함수 두개를 신중하게 작성해야 한다는 점인데 이는 종종 하나의 질의를 작성하는 것보다 어렵다.
더욱이 선언 형 질의 언어는 질의 최적화기가 질의 성능을 높일 수 있는 기회를 제공한다.
이런 이유로 몽고DB는 집계 파이프라인(aggregation pipeline)이라 부르는 선언형 질의 언어 지원을 추가했다.

집계 파이프라인 언어는 표현 측면에서 SQL의 부분 집합과 유사하지만 SQL의 영어 문장 스타일 구문보다는 JSON 기반 구문을 사용한다.
아마도 이 차이는 취향의 문제일 것이다.
여기서 배울점은 NoSQL 시스템이 뜻하지 않게 SQL을 재발견하고 있다는 것이다.


### 그래프형 데이터 모델

애플리케이션이 주로 일대다 관계 (트리 구조 데이터) 이거나 레코드 간 관계가 없다면 문서 모델이 적합하다.

하지만 데이터에서 다대다 관계가 매우 일반적이라면 어떻게 해야 할까?

관계형 모델은 단순한 다대다 관계를 다룰 수 있지만 데이터 간 연결이 복잡해지면 그래프로 데이터를 모델링하기 시작하는 편이 더 자연스럽다.

그래프는 두 유형의 객체로 이뤄진다.
정점(vertex) (노드 혹은 엔티티라고도 한다.)와 간선이다.

소셜 그래프, 웹 그래프, 도로나 철도 네트워크 등 많은 유형의 데이터를 그래프로 모델링 할 수 있다.

이런 그래프 상에서 동작하는 잘 알려진 여러 알고리즘이 있다.

그래프의 정점은 모두 같은 유형을 나타낸다.
하지만 그래프는 이런 동종 데이터에 국한되지 않는다.
그래프를 동종 데이터와 마찬가지 방식으로 사용하면 단일 테이터 저장소에 완전히 다른 유형의 객체를 일관성 있게 저장할 수 있는 강력한 방법을 제공한다.

그래프의 정점은 동정 데이터에 국한되지 않을 수 있다.

예를 들어 페이스북은 다른 여러 유형의 정점과 간선을 단일 그래프로 유지한다.

정점은 사람, 장소, 이벤트, 체크인, 사용자가 작성한 코멘트를 나타낸다.

간선은 어떤 사람이 서로 친구인지, 어떤 위치에서 체크인이 발생했는지 누가 어떤 포스트에 코멘트를 했는지 , 누가 이벤트에 참석했는지 등을 나타낸다.


### 속성 그래프

속성 그래프 모델에서 각 정점은 다음과 같은 요소로 구성된다.

- 고유한 식별자
- 유출 간선 집합 (outgoing)
- 유입 간선 집합 (incoming)
- 속성 컬렉션(키-값 쌍)

각 간선은 다음과 같은 요소로 구성된다.

- 고유한 식별자
- 간선이 시작하는 정점(꼬리 정점)
- 간선이 끝나는 정점(머리 정점)
- 두 정점 간 관계 유형을 설명하는 테이블
- 속성 컬렉션(키-값 쌍)

두 개의 관계형 테이블(하나는 정점이고 하나는 간선)로 구성된 그래프 저장소를 생각해보자.
예제 2-2의 스키마는 각 정점이나 간선 속성 저장을 위해 포스트그레스큐엘 json 데이터 타입을 사용했다.
머리와 꼬리 정점은 각 간선마다 저장된다.
정점을 위한 유입 간선과 유출 간선의 집합이 필요하다면 edges 테이블에 head_vertex 나 tail_vertex 로 각각 질의할 수 있다.


이 모델의 몇 가지 중요한 면은 다음과 같다.

- 정점은 다른 정점과 간선으로 연결된다. 특정 유형과 관련 여부를 제한하는 스키마는 없다.
- 정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다. 즉 일련의 정점을 따라 앞뒤 방향으로 순회한다.
  - tail_vertex 와 head_vertex 칼럼에 대해 색인을 생성하는 이유이다.
- 다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.

이런 기능을 통해 그래프는 데이터 모델링을 위한 많은 유연성을 제공한다.
국가마다 지역 구조가 다르다.
- 프랑스에서는 주와 도인 반면 미국에서는 군과 주다.

그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 애플리케이션의 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.



