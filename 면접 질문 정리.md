

- jpa 1차 캐시, 2차 캐시란?
  - 1차 캐시는 영속성 컨텍스트 내부에 있으며 osiv를 제외하면 트랜젝션 종료시 종료 
  - 따라서 애플리케이션 전체로 보면 데이터베이스 접근 횟수를 획기적으로 줄이지는 못한다.
  - 1차 캐시는 끄고 켤 수 있는 옵션이 아니다. 영속성 컨텍스트 자체가 사실상 1차 캐시다.
  - 2차 캐시는 하이버네이트를 포함한 대부분의 JPA 구현체들은 애플리케이션 범위의 캐시를 지원하는데 이것을 공유 캐시 또는 2차 캐시라 한다.


- 커버링 인덱스란?
  - 쿼리를 충족시키는데 필요한 모든 인덱스를 가지는 것
  - 즉 SELECT, WHERE, ORDER BY, GROUP BY 등에 사용되는 모든 컬럼이 인덱스의 구성요소인 경우를 얘기합니다.


- Clustered Key와 Non clustered key는?
  - 클러스터 형 인덱스는 데이터가 테이블에 물리적으로 저장 되는 순서를 정의(설정)한다. 즉, 클러스터 형 인덱스는 특정 컬럼을 기준으로 데이터들을 정렬시킨다. 아래 테이블은 id가 클러스터 형 인덱스로 지정되었으며, id 값을 기준으로 데이터들이 정렬되어있는 것을 확인할 수 있다.
  - 순서는 오직 하나의 컬럼으로 결정되기 때문에 중간에 새로운 데이터가 삽입된다면 이후의 모든 컬럼을 한 칸씩 이동시켜줘야한다. index가 군집화 되어있기 때문이다.

  - 논 클러스터 형 인덱스는 말 그대로 클러스터 형의 반대인 군집화 되어있지 않은 인덱스 타입이다. 그렇기 때문에 테이블에 저장 된 물리적인 순서에 따라 데이터를 정렬하지 않는다. 즉, 순서대로 정렬되어 있지 않다.
  논 클러스터 형 인덱스는 테이블 데이터와 함께 테이블에 저장되는 것이 아니라 별도의 장소에 저장된다. 마치, 위 책에서 index 페이지를 따로 나눈것 처럼 말이다. 그뿐만 아니라 하나의 테이블에 여러개의 논 클러스터 형 인덱스를 설정할 수 있다.

  - 논 클러스터 형의 예시는 아래와 같다. NonClustered 인덱스는 데이터의 행에 독립적이며, 인덱스 키 값과 데이터 행을 가리키는 포인터가 존재한다.

  - 테이블의 ID 키 값과 포인터인 Address를 통해 실제 데이터에 접근한다.
  - ID : 4 에 해당하는 가수의 이름을 알고 싶다면, 120번지로 이동하고, Name을 확인하면 된다. 그림에서 볼 수 있듯이 Clustered와의 차이는 순차적으로 index가 정렬되었지 않다는 점이다.

  - 어떤 경우에 생성해야할까?
  where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자할 때
  데이터가 자주 업데이트 될 때
  특정 컬럼이 쿼리에서 자주사용 될 때

  - Clustered 인덱스는 테이블당 오직 한개만 존재한다. 반면에 Non-Clustered 형은 테이블 당 여러개의 인덱스를 생성할 수 있다.
  - Clustered 인덱스는 오직 테이블을 정렬한다. 그러므로 별도의 공간을 필요로하지 않는다. Non-Clustered 인덱스는 저장되는 별도의 공간(약 10%)이 필요하다.
  - Clustered 인덱스는 통상적으로 데이터를 찾는데 추가적인 스텝을 거치지 않기 때문에 Non-Clustered 인덱스보다 속도가 빠르다.
  - Clustered 인덱스는 데이터를 삽입할 때, 모든 테이블에 존재하는 데이터들의 순서를 유지해야하므로 많은 비용이 발생한다. Non-Clustered는 별도의 공간에 인덱스를 생성해야하기 때문에 추가작업이 필요하다.


- 인덱스의 종류는?
  - 유니크 인덱스, 논 유니크 인덱스
  - 싱글, composite
  - 클러스터, 논 클러스터
  - function based
  - bitmap index
  - reversed key index

- 인덱스 스캔의 종류
  - 인덱스 풀스캔
  - 인덱스 fast full scan
  - index skip scan
  

- 카디널리티와 인덱스 설계란


- 비정규화, 정규화란?
  - 정규화란, RDBMS에서의 데이터의 중복을 최소화하는 작업을 말한다. 
  - 정규화를 많이 하게 되면 조인을 많이 해야하는 단점이 있다. 
  - 비정규화란, 반면 의도적으로 데이터를 중복시키거나, 데이터를 그룹핑함으로써, 성능을 최적화하는 작업이다.


- 데이터베이스 격리 수준
- 

- IoC, DI란
  - 제어의 역전으로 프로그래밍의 의존성을 프레임워크에서 관리하는 것
  - IoC의 일부로 의존성을 주입시켜주는 것을 의미

- AOP란, 사용해본 경험?


- 마이크로 서비스에 대해

- osiv란

- 프로세스, 스레드란

- 멀티 스레드 사용 방법, 사용 경험

- 무중단 배포 사용 경험

- 낙관적 락과 비관적 락이란

- 하이버네이트란

- 톰캣이란

- 웹서버와 웹 어플리케이션 서버란

- 인터넷 url 입력하면 벌어지는 일

- 쿠폰 발행 서비스 설계 방법, 어떻게 진행했는지

- ACID 란


- webflux 사용 경험?
  - 이벤트 루프 기반의 async, non-blocking 프로그래밍
  - mono & Flux , spring webflux 에서 사용하는 reactive libaryr 가 reactor 이고 reactor가 reactor streams 의 구현체. reactor의 주요 객체로 mono 와 flux가 있다.
  - mono: 한 번 응답하고 끝나는 방식으로 0-1개 데이터 요청에 응답할 때 사용
  - flux: 지속적으로 응답하는 방식으로 1개 이상의 데이터 요청에 대해 응답할때 사용
  - mono: reactive streams의 publisher 인터페이스를 구현하는 구현체인데, flux와의 차이점은 flux는 0-N개 데이터를 처리하지만, Mono는 0-1개 데이터를 처리한다. 데이터의 전달 처리가 완료되면 onComplete, 데이터를 전달하는 과정에서 오류가 발생하면 onError로 종료된다. 하나의 응답 결과만 리턴하면 되기 때문에 별도로 값은 필요없고, 완료 개념만 있으면 비동기 처리도 표현할 수 있다.
  - flux: flux는 reactive streams에서 정의한 Publisher의 구현체로서 0-N개 데이터를 발행할 수 있다. 하나의 데이터를 전달할 때 마다 onNext 이벤트를 발생한다. Flux 내의 모든 데이터 전달 처리가 완료 되면 onComplete 이벤트가 발생하며 데이터를 전달하는 과정에서 오류가 발생하면 onError 이벤트가 발생한다. 즉 onComplete나 onError가 되기 전까지는 무한 생성 가능한 Stream으로 생각해야 한다.





