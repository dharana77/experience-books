# AOP
**AOP는 IoC/ DI. 서비스 추상화** 와 더불어
스프링의 3대 기술 중 하나이다.

AOP는 스프링 기술 중 가장 이해하기 힘든 난해한
용어와 개념을 가진 기술로 악명이 높다.

AOP를 바르게 이용하려면 OOP를 대체하려고 하는 것처럼 보이는
AOP라는 이름 뒤에 감춰진 필연적 등장배경과 스프링이 그것을 도입한 이유,
적용을 통해 얻을 수 있는 강점이 무엇인지 충분한 이해가 필요하다.

가장 인기 있는 AOP의 적용 대상은 선언적 트랜젝션 기능이다.
서비스 추상화를 통해 많은 근본적 문제를 해결했던 트랜젝션
경계설정 기능을 AOP를 이용해 더 세련되고 깔끔한 방식으로 바꿔보자.

그 과정에서 스프링이 AOP를 도입해야 했던 이유도 알아보자.

## DI 적용을 이용한 트랜젝션 분리

직접 사용하는 것이 문제가 된다면 간접적으로 사용하면 된다.
DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘채
인터페이스를 통해 간접으로 접근하는 것이다.

그 덕분에 구현 클래스는 얼마든지 외부에서 변경할 수 있다.
바로 이런 개념을 가진 DI가 지금 필요하다.

interface UserService와

이를 구현한 UserService,
그리고 트랜젝션 기능을 가진
UserServiceTx를 구현한다.

- @Autowired는 기본적으로 타입이 일치하는 빈을 찾아준다.
같은 타입의 빈이 두개라면 @Autowired를 적용한 경우 어떤 빈을 가져올까?

기본적으로 타입을 이용해 빈을 찾지만 만약 타입으로 하나의 빈을 결정할 수 없는 경우에는 필드 이름을
이용해 빈을 찾는다.

따라서 UserServiceTest에서 다음과 같은 userService 변수를 설정해두면
아이디가 userService인 빈이 주입될 것이다.
@Autowired UserSerivce userService;

UserService는 인터페이스로 변경했으므로 테스트 코드는 이제 구체적인 클래스 정보는
알지 못한 채로 컨테이너가 제공하는 대표적인 UserService 구현 오브젝트를 사용하게 된다.
UserDao를 인터페이스로 바꿨을 때와 마찬가지라고 생각하면 된다.

그런데 UserServieTest는 하나의 빈을 더가져와야 한다.
바로 UserServiceImpl 클래스로 정의된 빈이다.
일반적인 UserService 기능의 테스트에서는 UserService
인터페이스를 통해 결과를 확인하는 것으로 충분하다.
그런데 앞에서 만든 MailSender 목 오브젝트를 이용한 테스트에서는
테스트에서 직접 MailSender를 DI해줘야 할 필요가 있었다.
MailSender를 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문에
UserServiceImpl 클래스의 오브젝트를 가져올 필요가 있다.


## 이런 수고를 한 결과로 얻을 수 있는 장점은 무엇인가?

1. 첫째로 이제 비즈니스 로직을 담당하고 있는 UserServiceImpl
를 작성할때는 트랜젝션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
트랜젝션의 적용이 필요한지도 신경쓰지 않아도 된다.

트랜젝션은 DI를 이용해 UserServieTx와 같은 트랜젝션 기능을 가진 오브젝트가
먼저 실행되도록 만들기만 하면 된다.
따라서 언제든지 트랜젝션을 도입할 수 있다.

트랜젝션 같은 기술적인 내용 때문에 잘 만들어 놓은 비즈니스 로직 코드에 괜히 손을 대서
엉망으로 만드는 불상사도 일어나지 않을 것이다.
스플이이나 트랜젝션 같은 로우레벨의 기술적인 지식은 부족한 비즈니스로 로직을 담은
UserService 클래스를 개발할 수 있다.

2. 두번째 장점은 비즈니스 로직에 대한 테스트를 손쉽게 만들어 낼 수 있다는 것이다.
이에 대해서는 좀더 자세히 알아보자.
